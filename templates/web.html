{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>AI Notebook</title>
  <!-- (Optional) Google Font for a nicer look -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap">
  <link href="/static/css/dark-mode.css" rel="stylesheet">

  <!-- Add Markdown parsing library -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  <!-- Add Material Icons -->
  <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />

  <style>
    /* Theme Variables - Default light theme */
    :root {
      --bg-color: #f5f7fa;
      --text-color: #12263f;
      --header-bg: #ffffff;
      --panel-bg: #f8f9fa;
      --panel-border: #d1d9e6;
      --card-bg: #ffffff;
      --card-border: #e3e8ef;
      --input-bg: #ffffff;
      --input-border: #d2ddec;
      --input-color: #12263f;
      --button-bg: #2c7be5;
      --button-color: #ffffff;
      --button-hover: #1a68d1;
      --message-user-bg: #e9f0f9;
      --message-assistant-bg: #f0f7fa;
      --message-summary-bg: #e1f5fa;
      --link-color: #2c7be5;
      --source-item-bg: #f0f7fa;
      --source-list-track: #f5f7fa;
      --source-list-thumb: #d1d9e6;
    }

    /* Dark Theme Variables */
    body.dark-mode {
      --bg-color: #121212;
      --text-color: #f0f0f0;
      --header-bg: #0d131b;
      --panel-bg: #12171f;
      --panel-border: #3a3a3a;
      --card-bg: #1e1e1e;
      --card-border: #333333;
      --input-bg: #1e1e1e;
      --input-border: #555555;
      --input-color: #f0f0f0;
      --button-bg: #444444;
      --button-color: #f2f2f2;
      --button-hover: #555555;
      --message-user-bg: #1e2a3a;
      --message-assistant-bg: #1b2a36;
      --message-summary-bg: #1b3042;
      --link-color: #61dafb;
      --source-item-bg: #1a2331;
      --source-list-track: #12171f;
      --source-list-thumb: #555;
    }

    /* Reset & Basic Defaults */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', sans-serif, Arial, sans-serif;
      background-color: var(--bg-color);
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      min-height: 100vh;
      padding: 0.5rem;
    }

    .container {
      display: flex;
      width: 100%;
      height: calc(100vh - 95px); /* Adjusted to account for header + margins */
      margin: 0;
      gap: 0.5rem;
      overflow: hidden; /* Prevent page-level scrolling */
    }

    /************************************
     * Panel Base Style
     ************************************/
    .panel {
      border: 2px dashed var(--panel-border);
      border-radius: 8px;
      padding: 1rem;
      display: flex;
      flex-direction: column;
      height: 100%; /* Use full container height */
      overflow: hidden; /* Prevent panel overflow */
      background-color: var(--panel-bg);
    }

    /************************************
     * Left Panel (Sources)
     ************************************/
    .left-panel {
      width: 300px;
      max-width: 320px;
    }

    .left-panel h2 {
      font-size: 1.2rem;
      margin-bottom: 0.8rem;
    }

    .add-source-btn {
      background-color: var(--button-bg);
      border: none;
      color: var(--button-color);
      padding: 0.6rem 1rem;
      margin-bottom: 1rem;
      cursor: pointer;
      font-size: 0.95rem;
      border-radius: 4px;
    }

    .add-source-btn:hover {
      background-color: var(--button-hover);
    }

    .sources-instructions {
      font-size: 0.9rem;
      line-height: 1.4rem;
      color: var(--text-color);
      opacity: 0.8;
      margin-bottom: 1rem; /* Reduced margin */
    }

    .saved-sources {
      display: flex;
      flex-direction: column;
      flex: 1; /* Take all available space */
      overflow: hidden; /* Prevent overflow */
      margin-top: 0; /* Remove margin */
    }

    .saved-sources h3 {
      font-size: 1rem;
      margin-bottom: 0.5rem;
    }

    .source-list {
      list-style: none;
      padding-left: 0;
      overflow-y: auto; /* Enable vertical scrolling */
      flex: 1; /* Take all available space */
      margin-bottom: 0;
      max-height: none; /* Remove max height limitation */
    }

    .source-list::-webkit-scrollbar {
      width: 8px;
    }

    .source-list::-webkit-scrollbar-track {
      background: var(--source-list-track);
      border-radius: 4px;
    }

    .source-list::-webkit-scrollbar-thumb {
      background: var(--source-list-thumb);
      border-radius: 4px;
    }

    .source-list::-webkit-scrollbar-thumb:hover {
      background: #777;
    }

    .source-list li {
      background-color: var(--source-item-bg);
      padding: 0.4rem;
      margin-bottom: 0.5rem;
      border-radius: 4px;
      font-size: 0.9rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .delete-btn {
      background: none;
      border: none;
      color: #ff4444;
      cursor: pointer;
      padding: 4px;
      opacity: 0.7;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: opacity 0.2s;
    }
    
    .delete-btn .material-icons {
      font-size: 18px; /* Smaller size to fit nicely in the list item */
    }
    
    .delete-btn:hover {
      opacity: 1;
    }

    /* Kebab menu styling for source items */
    .source-kebab-menu {
      position: relative;
    }
    
    .source-kebab-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--text-color);
      opacity: 0.7;
      transition: opacity 0.2s;
    }
    
    .source-kebab-btn:hover {
      opacity: 1;
    }
    
    .source-dropdown-menu {
      position: absolute;
      right: 0;
      top: 100%;
      background-color: var(--card-bg);
      border: 1px solid var(--panel-border);
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      min-width: 120px;
      z-index: 10;
      display: none;
    }
    
    .source-dropdown-menu.active {
      display: block;
    }
    
    .source-dropdown-item {
      display: flex;
      align-items: center;
      padding: 8px 12px;
      cursor: pointer;
      color: var(--text-color);
      font-size: 0.9rem;
      transition: background-color 0.2s;
    }
    
    .source-dropdown-item:hover {
      background-color: var(--source-item-bg);
    }
    
    .source-dropdown-item i {
      margin-right: 8px;
      font-size: 16px;
    }
    
    .source-dropdown-item.delete {
      color: var(--danger);
    }

    /************************************
     * Right Panel (Chat)
     ************************************/
    .right-panel {
      flex: 1;
      display: flex;
      flex-direction: column;
    }

    .right-panel h2 {
      font-size: 1.2rem;
      margin-bottom: 0.8rem;
    }

    /* The main chat container (holds messages & input) */
    .chat-container {
      display: flex;
      flex-direction: column;
      flex: 1;
      margin-bottom: 0.5rem; /* Reduced margin */
      border: 2px dashed var(--panel-border);
      border-radius: 8px;
      padding: 1rem;
      overflow: hidden; /* Important: prevent container overflow */
    }

    /* The scrollable area where chat messages appear */
    .chat-messages {
      flex: 1;
      overflow-y: auto; /* This enables vertical scrolling */
      overflow-x: hidden; /* Prevent horizontal scrolling */
      margin-bottom: 0.8rem;
      padding-right: 0.5rem; /* space for scrollbar */
      min-height: 300px; /* Ensure minimum height for scrolling */
    }

    .message {
      background-color: var(--message-assistant-bg);
      padding: 0.6rem;
      margin-bottom: 0.5rem;
      border-radius: 4px;
      max-width: 80%;
      font-size: 0.9rem;
      line-height: 1.3rem;
      word-wrap: break-word;
    }

    /* Align user messages to the right if you like, or keep them all on the left */
    .message.user {
      margin-left: auto;
      background-color: var(--message-user-bg);
    }

    /* The input area for new messages */
    .chat-input {
      display: flex;
      gap: 0.5rem;
    }

    .chat-input textarea {
      flex: 1;
      padding: 0.6rem;
      border-radius: 4px;
      border: 1px solid var(--input-border);
      background-color: var(--input-bg);
      color: var(--input-color);
      font-family: inherit;
      font-size: 0.9rem;
      line-height: 1.2;
      overflow-y: auto;
      min-height: 40px;
      max-height: 120px;
    }

    .chat-input textarea::placeholder {
      color: var(--text-color);
      opacity: 0.6;
    }

    .send-btn {
      background-color: var(--button-bg);
      border: none;
      color: var(--button-color);
      padding: 0.6rem 1rem;
      cursor: pointer;
      font-size: 0.9rem;
      border-radius: 4px;
    }

    .send-btn:hover {
      background-color: var(--button-hover);
    }

    /* Responsive: stack panels vertically on narrow screens */
    @media (max-width: 768px) {
      .container {
        flex-direction: column;
      }
      .left-panel {
        width: 100%;
        margin-bottom: 0.5rem;
      }
      .right-panel {
        width: 100%;
      }
    }

    /* Add styling for sources in chat messages */
    .message .sources {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      color: var(--text-color);
      opacity: 0.6;
    }

    .message.assistant {
      background-color: var(--message-assistant-bg);
    }

    /* Preserve whitespace in messages */
    .message .message-text {
      white-space: pre-wrap;  /* This preserves whitespace and wraps text */
      word-break: break-word;
    }

    /* Add styling for markdown content */
    .markdown-content {
      line-height: 1.5;
    }
    
    .markdown-content p {
      margin-bottom: 1rem;
    }
    
    .markdown-content h1, 
    .markdown-content h2, 
    .markdown-content h3, 
    .markdown-content h4 {
      margin-top: 1rem;
      margin-bottom: 0.5rem;
      font-weight: bold;
    }
    
    .markdown-content code {
      background-color: rgba(0, 0, 0, 0.1);
      padding: 0.2em 0.4em;
      border-radius: 3px;
      font-family: monospace;
    }
    
    .markdown-content pre {
      background-color: rgba(0, 0, 0, 0.1);
      padding: 1rem;
      border-radius: 4px;
      overflow-x: auto;
      max-width: 100%;
      margin: 1rem 0;
    }
    
    .markdown-content pre code {
      background-color: transparent;
      padding: 0;
    }
    
    .markdown-content ul, 
    .markdown-content ol {
      margin-left: 2rem;
      margin-bottom: 1rem;
    }
    
    .markdown-content blockquote {
      border-left: 3px solid var(--panel-border);
      padding-left: 1rem;
      margin-left: 0;
      margin-right: 0;
      font-style: italic;
    }
    
    .markdown-content table {
      border-collapse: collapse;
      margin-bottom: 1rem;
      width: 100%;
    }
    
    .markdown-content th, 
    .markdown-content td {
      border: 1px solid var(--panel-border);
      padding: 0.5rem;
    }
    
    .markdown-content a {
      color: var(--link-color);
      text-decoration: none;
    }
    
    .markdown-content a:hover {
      text-decoration: underline;
    }
    
    /* Style scrollbars for better visibility */
    .chat-messages::-webkit-scrollbar {
      width: 8px;
    }
    
    .chat-messages::-webkit-scrollbar-track {
      background: var(--source-list-track);
      border-radius: 4px;
    }
    
    .chat-messages::-webkit-scrollbar-thumb {
      background: var(--source-list-thumb);
      border-radius: 4px;
    }
    
    .chat-messages::-webkit-scrollbar-thumb:hover {
      background: #777;
    }

    /* Title/Header styling */
    .header {
      background-color: var(--header-bg);
      margin-bottom: 0.5rem;
      border-radius: 8px;
      width: 100%;
    }
    
    .header-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem;
    }
    
    .header-left {
      flex: 0 0 auto;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .header-center {
      flex: 1;
      display: flex;
      justify-content: center;
    }
    
    .header-right {
      flex: 0 0 auto;
      text-align: right;
    }
    
    .dashboard-link {
      color: var(--link-color);
      text-decoration: none;
      font-size: 1.2rem;
      font-weight: 600;
      transition: color 0.2s;
    }
    
    .dashboard-link:hover {
      color: var(--button-hover);
      text-decoration: underline;
    }
    
    .header h1 {
      font-size: 1.8rem;
      font-weight: 600;
      color: var(--text-color);
      letter-spacing: 1px;
      margin: 0;
    }

    /* Structure left panel content with flex */
    .left-panel-content {
      display: flex;
      flex-direction: column;
      height: 100%;
    }
    
    .sources-top {
      flex: 0 0 auto; /* Don't grow or shrink */
    }
    
    .sources-bottom {
      flex: 1; /* Take remaining space */
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0; /* Important for nested flexbox scrolling */
    }

    /* Source item action buttons styling */
    .source-actions {
      display: flex;
      gap: 4px;
    }

    .source-item-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      width: 100%;
    }
    
    .source-name {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 180px; /* Limit width so actions stay visible */
    }
    
    .action-btn {
      background: none;
      border: none;
      cursor: pointer;
      padding: 4px;
      opacity: 0.7;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: opacity 0.2s;
    }
    
    .action-btn .material-icons {
      font-size: 18px;
    }
    
    .action-btn:hover {
      opacity: 1;
    }
    
    .summarize-btn {
      color: var(--link-color);
    }
    
    .delete-btn {
      color: #ff4444;
    }
    
    /* Loading spinner for summarization */
    .spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(97, 218, 251, 0.3);
      border-radius: 50%;
      border-top-color: var(--link-color);
      animation: spin 1s ease-in-out infinite;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    .summary-message {
      background-color: var(--message-summary-bg) !important; /* Special background for summaries */
    }
    
    .summary-header {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 8px;
      font-weight: 600;
    }

    /* Theme toggle styles */
    .theme-toggle {
      background: none;
      border: none;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: var(--text-color);
      font-size: 0.9rem;
      padding: 0.5rem;
      border-radius: 4px;
    }

    .theme-toggle:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .theme-toggle i {
      font-size: 18px;
    }
  </style>
</head>
<body>
<!-- Update header with navigation link and project title side by side -->
<div class="header">
  <div class="header-content">
    <div class="header-left">
      <a href="/" class="dashboard-link">AI Notebook</a>
    </div>
    <div class="header-center">
      <h1 id="projectTitle">Project Title</h1>
    </div>
    <div class="header-right">
      <!-- Add any right-aligned content here -->
    </div>
  </div>
</div>

<div class="container">
  <!-- Left Panel: Sources -->
  <div class="left-panel panel" id="leftPanel">
    <div class="left-panel-content">
      <div class="sources-top">
        <h2>Sources</h2>
        <!-- Update button to trigger file explorer -->
        <button class="add-source-btn" onclick="openFileExplorer()">+ Add source</button>
        <input type="file" id="fileInput" style="display: none;" onchange="uploadFile(this.files)" multiple accept=".pdf" />
        <p class="sources-instructions">
          Saved sources will appear here. Drag and drop files here or click "+ Add source" to add PDFs, websites,
          text, videos, or audio files. You can now select multiple files at once!
        </p>
      </div>
      
      <!-- Add upload progress indicator -->
      <div id="uploadProgress" style="display: none; margin-bottom: 1rem;">
        <div style="font-size: 0.9rem; margin-bottom: 0.5rem;">Uploading files: <span id="uploadCounter">0/0</span></div>
        <div class="progress-bar-container" style="height: 4px; background-color: #333; border-radius: 2px;">
          <div id="progressBar" class="progress-bar" style="height: 100%; width: 0%; background-color: #2c7be5; border-radius: 2px; transition: width 0.3s;"></div>
        </div>
        <!-- Add individual file progress display -->
        <div id="currentFileProgress" style="font-size: 0.8rem; margin-top: 0.5rem; color: #aaa;">
          Current file: <span id="currentFileName">--</span>
          <div class="progress-bar-container" style="height: 3px; background-color: #333; border-radius: 2px; margin-top: 3px;">
            <div id="fileProgressBar" class="progress-bar" style="height: 100%; width: 0%; background-color: #4caf50; border-radius: 2px; transition: width 0.1s;"></div>
          </div>
          <span id="fileProgressText">0%</span>
        </div>
      </div>
      
      <div class="sources-bottom">
        <div class="saved-sources">
          <h3>Saved Sources:</h3>
          <ul id="sourceList" class="source-list">
            <!-- Dynamically added sources will appear here -->
          </ul>
        </div>
      </div>
    </div>
  </div>

  <!-- Right Panel: Chat -->
  <div class="right-panel panel">
    <h2>Chat</h2>
    <!-- Chat area (messages + input) -->
    <div class="chat-container">
      <div id="chatMessages" class="chat-messages">
        <!-- Chat messages go here -->
      </div>
      <div class="chat-input">
        <textarea
          id="chatInput"
          placeholder="Type your message... (Shift+Enter for new line)"
          rows="1"
          style="resize: none;"
          onkeydown="handleKeyDown(event)"
        ></textarea>
        <button class="send-btn" onclick="sendMessage()">Send</button>
      </div>
    </div>
  </div>
</div>

<script>
  // Initialize theme based on localStorage preference
  document.addEventListener("DOMContentLoaded", function() {
    const darkModeEnabled = localStorage.getItem('darkMode') === 'enabled';
    const themeToggle = document.getElementById('themeToggle');
    
    // Set initial theme state based on localStorage
    if (darkModeEnabled) {
      document.body.classList.add('dark-mode');
      themeToggle.querySelector('i').textContent = 'light_mode';
      themeToggle.querySelector('span').textContent = 'Light Mode';
    } else {
      document.body.classList.remove('dark-mode');
      themeToggle.querySelector('i').textContent = 'dark_mode';
      themeToggle.querySelector('span').textContent = 'Dark Mode';
    }
    
    // Setup theme toggle functionality
    themeToggle.addEventListener('click', () => {
      document.body.classList.toggle('dark-mode');
      const isDarkMode = document.body.classList.contains('dark-mode');
      
      // Update toggle button UI
      themeToggle.querySelector('i').textContent = isDarkMode ? 'light_mode' : 'dark_mode';
      themeToggle.querySelector('span').textContent = isDarkMode ? 'Light Mode' : 'Dark Mode';
      
      // Save preference to localStorage
      localStorage.setItem('darkMode', isDarkMode ? 'enabled' : 'disabled');
    });
    
    // Other initialization
    fetchSourcesList();
  });

  /********************************************
   * Data Structures
   ********************************************/
  const sources = [];
  const chatMessages = [];
  // Get project ID from URL query parameter
  const urlParams = new URLSearchParams(window.location.search);
  const currentProjectId = urlParams.get('project_id');
  
  if (!currentProjectId) {
    alert('No project ID specified. Redirecting to projects dashboard.');
    window.location.href = '/';
  }

  // Add project ID to document title
  fetch(`/api/projects/${currentProjectId}`)
    .then(response => {
      if (!response.ok) throw new Error('Failed to load project');
      return response.json();
    })
    .then(project => {
      document.title = `${project.title} - AI Notebook`;
      document.getElementById('projectTitle').textContent = project.title;
    })
    .catch(error => {
      console.error('Error loading project:', error);
    });

  // Fetch the list of sources when the page loads
  document.addEventListener("DOMContentLoaded", function() {
    fetchSourcesList();
  });

  // Function to fetch the list of sources from the server
  function fetchSourcesList() {
    fetch(`/list_sources/${currentProjectId}`)
      .then(response => response.json())
      .then(data => {
        // Clear existing sources
        sources.length = 0;
        
        // Add fetched sources to our array
        data.sources.forEach(source => {
          sources.push(source.filename);
        });
        
        // Update the UI
        updateSourceList();
      })
      .catch(error => {
        console.error("Error fetching sources list:", error);
      });
  }

  /********************************************
   * Sources Logic
   ********************************************/
  function updateSourceList() {
    const sourceListEl = document.getElementById("sourceList");
    sourceListEl.innerHTML = "";
    
    // Track any open dropdowns
    let openDropdown = null;
    
    // Close any open dropdown when clicking elsewhere
    document.addEventListener('click', function(e) {
      if (openDropdown && !openDropdown.contains(e.target)) {
        openDropdown.querySelector('.source-dropdown-menu').classList.remove('active');
        openDropdown = null;
      }
    });

    sources.forEach((src) => {
      const li = document.createElement("li");
      
      // Create content container for better layout control
      const sourceItemContent = document.createElement("div");
      sourceItemContent.className = "source-item-content";
      
      // Add filename
      const filename = document.createElement("div");
      filename.className = "source-name";
      filename.textContent = src;
      sourceItemContent.appendChild(filename);
      
      // Create kebab menu container
      const kebabMenuContainer = document.createElement("div");
      kebabMenuContainer.className = "source-kebab-menu";
      
      // Create kebab button (three vertical dots)
      const kebabBtn = document.createElement("button");
      kebabBtn.className = "source-kebab-btn";
      kebabBtn.innerHTML = '<i class="material-icons">more_vert</i>';
      kebabBtn.setAttribute("title", "Options");
      kebabMenuContainer.appendChild(kebabBtn);
      
      // Create dropdown menu
      const dropdownMenu = document.createElement("div");
      dropdownMenu.className = "source-dropdown-menu";
      
      // Add summarize option
      const summarizeItem = document.createElement("div");
      summarizeItem.className = "source-dropdown-item";
      summarizeItem.innerHTML = '<i class="material-icons">summarize</i> Summarize';
      summarizeItem.onclick = (e) => {
        e.stopPropagation();
        // Hide dropdown
        dropdownMenu.classList.remove('active');
        // Perform action
        summarizeDocument(src);
      };
      dropdownMenu.appendChild(summarizeItem);
      
      // Add delete option
      const deleteItem = document.createElement("div");
      deleteItem.className = "source-dropdown-item delete";
      deleteItem.innerHTML = '<i class="material-icons">delete</i> Delete';
      deleteItem.onclick = (e) => {
        e.stopPropagation();
        // Hide dropdown
        dropdownMenu.classList.remove('active');
        // Perform action
        deleteSource(src);
      };
      dropdownMenu.appendChild(deleteItem);
      
      // Add dropdown to kebab menu container
      kebabMenuContainer.appendChild(dropdownMenu);
      
      // Add click handler for kebab button
      kebabBtn.onclick = (e) => {
        e.stopPropagation();
        
        // Close any previously open dropdown
        if (openDropdown && openDropdown !== kebabMenuContainer) {
          openDropdown.querySelector('.source-dropdown-menu').classList.remove('active');
        }
        
        // Toggle current dropdown
        dropdownMenu.classList.toggle('active');
        
        // Update current open dropdown reference
        openDropdown = dropdownMenu.classList.contains('active') ? kebabMenuContainer : null;
      };
      
      sourceItemContent.appendChild(kebabMenuContainer);
      li.appendChild(sourceItemContent);
      sourceListEl.appendChild(li);
    });
  }

  function deleteSource(filename) {
    if (confirm(`Are you sure you want to delete ${filename}?`)) {
      fetch(`/delete_source/${currentProjectId}/${encodeURIComponent(filename)}`, {
        method: 'DELETE'
      })
      .then(response => {
        console.log("Delete response status:", response.status);
        
        // If file was successfully deleted (server returned 200 OK)
        if (response.ok) {
          // Attempt to parse JSON but don't reject if it's not valid JSON
          return response.text().then(text => {
            try {
              // Try to parse as JSON if possible
              return text ? JSON.parse(text) : { message: "File deleted successfully" };
            } catch (e) {
              // If not valid JSON, return a default success message
              console.log("Response is not valid JSON:", text);
              return { message: "File deleted successfully" };
            }
          });
        }
        
        // For error responses, try to get error details
        if (response.status === 404) {
          return { error: true, message: "File not found" };
        }
        
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      })
      .then(data => {
        // Remove the file from our local array regardless of response
        const fileIndex = sources.indexOf(filename);
        if (fileIndex !== -1) {
          sources.splice(fileIndex, 1);
          updateSourceList();  // Update UI immediately
        }
        
        // Show appropriate message based on response
        if (data.error) {
          alert(`Note: ${data.message}. The file list has been refreshed.`);
        } else {
          alert(data.message || "File deleted successfully");
        }
        
        // Refresh from server to ensure we're in sync
        fetchSourcesList();
      })
      .catch(error => {
        console.error("Error in delete operation:", error);
        
        // Even if there's an error in processing the response,
        // the file might have been deleted successfully
        alert("The file may have been deleted. Refreshing file list...");
        
        // Always refresh the list to get the current state
        fetchSourcesList();
      });
    }
  }

  function verifyFileExists(filename) {
    fetch(`/check_file/${currentProjectId}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ filename: filename })
    })
    .then(response => response.json())
    .then(data => {
      if (!data.exists) {
        alert(`File '${filename}' is no longer on the server. Refreshing source list...`);
        fetchSourcesList();
      }
    })
    .catch(error => {
      console.error("Error checking file:", error);
    });
  }

  function openFileExplorer() {
    document.getElementById("fileInput").click();
  }

  function verifyFileUpload(filename) {
    // Verify if a file was actually uploaded despite client-side errors
    fetch(`/check_file/${currentProjectId}`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ filename: filename })
    })
    .then(response => response.json())
    .then(data => {
      console.log(`File verification for ${filename}: ${data.exists ? "exists" : "does not exist"}`);
    })
    .catch(error => {
      console.error("Error verifying file upload:", error);
    });
  }

  function uploadFile(files) {
    if (files.length === 0) return;
    
    console.log(`Starting upload of ${files.length} files`);
    
    // Show progress elements
    const progressContainer = document.getElementById('uploadProgress');
    const progressBar = document.getElementById('progressBar');
    const uploadCounter = document.getElementById('uploadCounter');
    const currentFileName = document.getElementById('currentFileName');
    const fileProgressBar = document.getElementById('fileProgressBar');
    const fileProgressText = document.getElementById('fileProgressText');
    
    progressContainer.style.display = 'block';
    progressBar.style.width = '0%';
    uploadCounter.textContent = `0/${files.length}`;
    
    let completedUploads = 0;
    let failedUploads = 0;
    
    // Process each file sequentially to avoid overwhelming the server
    async function uploadNext(index) {
      if (index >= files.length) {
        // All files have been processed
        console.log(`Upload process completed: ${completedUploads} succeeded, ${failedUploads} failed`);
        
        // If we have failed uploads, offer to retry them
        if (failedUploads > 0 && completedUploads > 0) {
          // Add small delay before showing the completion alert
          setTimeout(() => {
            progressContainer.style.display = 'none';
            alert(`Upload partially complete. ${completedUploads} files uploaded, ${failedUploads} files failed.`);
            
            // Rebuild index after uploads are complete
            rebuildIndex();
            
            // Refresh the sources list
            fetchSourcesList();
          }, 500);
        } else if (failedUploads > 0) {
          setTimeout(() => {
            progressContainer.style.display = 'none';
            alert(`Upload failed. None of the files were uploaded. Please try again with smaller files or fewer files at once.`);
            fetchSourcesList();
          }, 500);
        } else {
          setTimeout(() => {
            progressContainer.style.display = 'none';
            alert(`Successfully uploaded all ${completedUploads} files!`);
            
            // Rebuild index after uploads are complete
            rebuildIndex();
            
            // Refresh the sources list
            fetchSourcesList();
          }, 500);
        }
        return;
      }
      
      const file = files[index];
      console.log(`Processing file ${index + 1}/${files.length}: ${file.name} (${Math.round(file.size/1024)} KB)`);
      const formData = new FormData();
      formData.append("file", file);
      
      // Update current file display
      currentFileName.textContent = `${file.name} (${Math.round(file.size/1024)} KB)`;
      fileProgressBar.style.width = '0%';
      fileProgressText.textContent = '0%';
      
      let retryCount = 0;
      const maxRetries = 2; // Maximum number of retries per file
      
      async function attemptUpload() {
        try {
          // Use XMLHttpRequest for upload progress tracking
          await new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            
            // Increased timeout to 60 seconds (from 30)
            xhr.timeout = 60000;
            
            // Progress event listener
            xhr.upload.addEventListener('progress', (event) => {
              if (event.lengthComputable) {
                const percentComplete = Math.round((event.loaded / event.total) * 100);
                fileProgressBar.style.width = percentComplete + '%';
                fileProgressText.textContent = percentComplete + '%';
              }
            });
            
            // Setup completion handlers
            xhr.onload = () => {
              if (xhr.status >= 200 && xhr.status < 300) {
                completedUploads++;
                console.log(`File ${index + 1} (${file.name}) uploaded successfully`);
                resolve();
              } else {
                console.error(`Server error uploading ${file.name}: Status ${xhr.status} - ${xhr.statusText}`);
                reject(new Error(`Server returned status ${xhr.status}: ${xhr.statusText}`));
              }
            };
            
            xhr.ontimeout = () => {
              console.error(`Timeout uploading ${file.name}`);
              reject(new Error('Upload timed out'));
            };
            
            xhr.onerror = () => {
              console.error(`Network error uploading ${file.name}`);
              reject(new Error('Network Error'));
            };
            
            // Open and send request
            xhr.open('POST', `/upload_source/${currentProjectId}`);
            xhr.send(formData);
          });
          
          return true; // Upload succeeded
        } catch (error) {
          console.error(`Error uploading file ${file.name} (attempt ${retryCount + 1}):`, error);
          
          if (retryCount < maxRetries) {
            retryCount++;
            fileProgressText.textContent = `Retrying... (${retryCount}/${maxRetries})`;
            // Wait a bit longer before retrying large files
            await new Promise(resolve => setTimeout(resolve, 2000));
            return await attemptUpload(); // Retry
          }
          
          failedUploads++;
          return false; // Upload failed after all retries
        }
      }
      
      await attemptUpload();
      
      // Update overall progress
      const progress = Math.round(((index + 1) / files.length) * 100);
      progressBar.style.width = `${progress}%`;
      uploadCounter.textContent = `${index + 1}/${files.length}`;
      
      // Move to next file
      console.log(`Moving to next file (index ${index + 1})`);
      await uploadNext(index + 1);
    }
    
    // Start the upload process
    uploadNext(0);
  }
  
  // Function to rebuild the index after uploads complete
  function rebuildIndex() {
    fetch(`/rebuild_index/${currentProjectId}`, {
      method: 'POST'
    })
    .then(response => response.json())
    .then(data => {
      console.log('Index rebuilt:', data.message);
    })
    .catch(error => {
      console.error('Error rebuilding index:', error);
    });
  }
  
  // Enable drag and drop for multiple files
  const leftPanel = document.getElementById("leftPanel");
  leftPanel.addEventListener("dragover", function(e) {
    e.preventDefault();
    leftPanel.style.borderColor = "#5a5a5a";
  });
  leftPanel.addEventListener("dragleave", function(e) {
    e.preventDefault();
    leftPanel.style.borderColor = "";
  });
  leftPanel.addEventListener("drop", function(e) {
    e.preventDefault();
    leftPanel.style.borderColor = "";
    if (e.dataTransfer.files.length > 0) {
      uploadFile(e.dataTransfer.files);
    }
  });

  /********************************************
   * Chat Logic
   ********************************************/
  function sendMessage() {
    const chatInput = document.getElementById("chatInput");
    const messageText = chatInput.value.trim();
    if (messageText !== "") {
      // Add user message to chat
      chatMessages.push({ text: messageText, sender: "user" });
      renderChatMessages();
      chatInput.value = "";

      // Send query to model with project ID
      fetch("/ask", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify({ 
          query: messageText,
          project_id: currentProjectId
        })
      })
      .then(response => response.json())
      .then(data => {
        // Add model's response to chat
        chatMessages.push({ 
          text: data.answer, 
          sender: "assistant",
          sources: data.sources 
        });
        renderChatMessages();
      })
      .catch(error => {
        console.error("Error getting response:", error);
        chatMessages.push({ 
          text: "Sorry, I encountered an error processing your request.", 
          sender: "assistant" 
        });
        renderChatMessages();
      });
    }
  }

  /********************************************
   * Summarization Logic
   ********************************************/
  function summarizeDocument(filename) {
    // Add a message to the chat showing summarization in progress
    const loadingMessageId = Date.now();
    chatMessages.push({ 
      id: loadingMessageId,
      text: `<div class="summary-header"><div class="spinner"></div> Generating summary for ${filename}...</div>`, 
      sender: "assistant",
      isHTML: true
    });
    renderChatMessages();
    
    // Create an AbortController to handle timeouts
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 1800000); // 30-minute timeout (1800000ms)
    
    // Call the API to summarize the document with increased timeout
    fetch("/summarize", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ 
        project_id: currentProjectId,
        filename: filename
      }),
      signal: controller.signal
    })
    .then(response => {
      clearTimeout(timeoutId); // Clear the timeout
      if (!response.ok) {
        throw new Error(`Server returned ${response.status}: ${response.statusText}`);
      }
      return response.text(); // Changed from response.json() to handle plain text response
    })
    .then(summaryText => {
      // Remove the loading message
      const index = chatMessages.findIndex(msg => msg.id === loadingMessageId);
      if (index !== -1) {
        chatMessages.splice(index, 1);
      }
      
      // Add the summary to chat without the JSON structure or filename header
      chatMessages.push({ 
        text: summaryText, 
        sender: "assistant",
        isSpecial: "summary"
      });
      renderChatMessages();
    })
    .catch(error => {
      clearTimeout(timeoutId); // Clear the timeout if error occurs
      console.error("Error generating summary:", error);
      
      // Check if this was a timeout error
      let errorMessage = error.message;
      if (error.name === 'AbortError') {
        errorMessage = "The summarization process took longer than 30 minutes and timed out. Try again with a smaller document or break the document into parts.";
      } else if (error.message.includes("NetworkError")) {
        errorMessage = "Network connection error. The document might be too large for summarization or the server might be under heavy load. Try again or try with a smaller document.";
      }
      
      // Update the loading message with error
      const index = chatMessages.findIndex(msg => msg.id === loadingMessageId);
      if (index !== -1) {
        chatMessages[index] = {
          text: `Error generating summary for ${filename}: ${errorMessage}`,
          sender: "assistant"
        };
        renderChatMessages();
      }
    });
  }

  function renderChatMessages() {
    const chatMessagesEl = document.getElementById("chatMessages");
    chatMessagesEl.innerHTML = "";

    chatMessages.forEach((msg) => {
      const msgDiv = document.createElement("div");
      msgDiv.classList.add("message");
      
      if (msg.sender === "user") {
        msgDiv.classList.add("user");
      } else if (msg.sender === "assistant") {
        msgDiv.classList.add("assistant");
        
        // Add special class for summaries
        if (msg.isSpecial === "summary") {
          msgDiv.classList.add("summary-message");
        }
      }
      
      // Check if the message contains HTML that should be directly inserted
      if (msg.isHTML) {
        msgDiv.innerHTML = msg.text;
      } else {
        // Add message text with markdown rendering
        const textDiv = document.createElement("div");
        textDiv.className = "message-text markdown-content";
        
        // Use the marked library to render markdown
        marked.setOptions({
          breaks: true,
          gfm: true,
          headerIds: false,
          sanitize: false
        });
        
        // Check if this is JSON and hide it if the user doesn't want JSON displayed
        let textToDisplay = msg.text;
        if (textToDisplay && typeof textToDisplay === 'string') {
          // Check if this looks like JSON (starts with { or [)
          if ((textToDisplay.trim().startsWith('{') && textToDisplay.trim().endsWith('}')) || 
              (textToDisplay.trim().startsWith('[') && textToDisplay.trim().endsWith(']'))) {
            try {
              // Try to parse it as JSON to confirm it's valid JSON
              JSON.parse(textToDisplay);
              // If it's valid JSON, replace with a message
              textToDisplay = "The response contains JSON data that has been hidden.";
            } catch (e) {
              // Not valid JSON, leave as is
            }
          }
        }
        
        try {
          textDiv.innerHTML = marked.parse(textToDisplay);
        } catch (e) {
          textDiv.textContent = textToDisplay;
          console.error("Markdown parsing error:", e);
        }
        
        msgDiv.appendChild(textDiv);
        
        // Add sources if available (for assistant messages)
        if (msg.sources && msg.sender === "assistant") {
          const sourcesDiv = document.createElement("div");
          sourcesDiv.className = "sources";
          sourcesDiv.innerHTML = "<br><small>Sources:</small>";
          msg.sources.forEach((source, index) => {
            sourcesDiv.innerHTML += `<br><small>${index + 1}. ${source.metadata.filename}</small>`;
          });
          msgDiv.appendChild(sourcesDiv);
        }
      }
      
      chatMessagesEl.appendChild(msgDiv);
    });

    // Auto-scroll to bottom
    chatMessagesEl.scrollTop = chatMessagesEl.scrollHeight;
  }

  function handleKeyDown(event) {
    const textarea = event.target;
    if (event.key === 'Enter') {
      if (event.shiftKey) {
        // Let the newline be added naturally
        return;
      }
      event.preventDefault();
      sendMessage();
    }
    
    // Auto-adjust height
    setTimeout(() => {
      textarea.style.height = 'auto';
      textarea.style.height = textarea.scrollHeight + 'px';
    }, 0);
  }

  // Theme toggle logic
  const themeToggle = document.getElementById('themeToggle');
  themeToggle.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    const isDarkMode = document.body.classList.contains('dark-mode');
    themeToggle.querySelector('i').textContent = isDarkMode ? 'light_mode' : 'dark_mode';
    themeToggle.querySelector('span').textContent = isDarkMode ? 'Light Mode' : 'Dark Mode';
  });

</script>

</body>
</html>